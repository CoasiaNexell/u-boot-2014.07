#include <common.h>
#include <platform.h>
#include <asm/gpio.h>
#include <gpio.h>
#include <camera.h>
#include <vip.h>
#include <mlc.h>
#include <pwm.h>
#include <i2c.h>
#include <power/axp228.h>

//#define VIP_MODULE_NUM  0
#define VIP_MODULE_NUM  1

// #define FEATURE_TW9992
#define CONFIG_VIDEO_SP2518_FIXED_FRAMERATE

#if 1
static struct reg_val _sensor_init_data[] =
{
	{0xfd,0x00},
  {0x1b,0x1a},//maximum drv ability
  {0x0e,0x01},
  {0x0f,0x2f},
  {0x10,0x2e},
  {0x11,0x00},
  {0x12,0x4f},
  {0x14,0x40},//20
  {0x16,0x02},
  {0x17,0x10},
  {0x1a,0x1f},
  {0x1e,0x81},
  {0x21,0x00},
  {0x22,0x1b},
  {0x25,0x10},
  {0x26,0x25},
  {0x27,0x6d},
  {0x2c,0x23},//31 Ronlus remove balck dot0x45},
  {0x2d,0x75},
  {0x2e,0x38},//sxga 0x18
    // psw0523 fix
#ifndef CONFIG_VIDEO_SP2518_FIXED_FRAMERATE
  {0x31,0x10},//mirror upside down
    // fix for 30frame
  /* {0x31,0x00},//mirror upside down */
#else
  {0x31,0x18},//mirror upside down
#endif // CONFIG_VIDEO_SP2518_FIXED_FRAMERATE
    // end psw0523
    // psw0523 add for 656
    /* {0x36, 0x1f}, // bit1: ccir656 output enable */
    // end psw0523
  {0x44,0x03},
  {0x6f,0x00},
  {0xa0,0x04},
  {0x5f,0x01},
  {0x32,0x00},
  {0xfd,0x01},
  {0x2c,0x00},
  {0x2d,0x00},
  {0xfd,0x00},
  {0xfb,0x83},
  {0xf4,0x09},
  //Pregain
  {0xfd,0x01},
  {0xc6,0x90},
  {0xc7,0x90},
  {0xc8,0x90},
  {0xc9,0x90},
  //blacklevel
  {0xfd,0x00},
  {0x65,0x08},
  {0x66,0x08},
  {0x67,0x08},
  {0x68,0x08},

  //bpc
  {0x46,0xff},
  //rpc
  {0xfd,0x00},
  {0xe0,0x6c},
	{0xe1,0x54},
  {0xe2,0x48},
  {0xe3,0x40},
  {0xe4,0x40},
  {0xe5,0x3e},
  {0xe6,0x3e},
  {0xe8,0x3a},
  {0xe9,0x3a},
  {0xea,0x3a},
  {0xeb,0x38},
  {0xf5,0x38},
  {0xf6,0x38},
  {0xfd,0x01},
  {0x94,0xcC},//f8 C0
  {0x95,0x38},
  {0x9c,0x74},//6C
  {0x9d,0x38},
#ifndef CONFIG_VIDEO_SP2518_FIXED_FRAMERATE
  /*24*3pll 8~13fps 50hz*/
  {0xfd , 0x00},
  {0x03 , 0x03},
  {0x04 , 0xf6},
  {0x05 , 0x00},
  {0x06 , 0x00},
  {0x07 , 0x00},
  {0x08 , 0x00},
  {0x09 , 0x00},
  {0x0a , 0x8b},
  {0x2f , 0x00},
  {0x30 , 0x08},
  {0xf0 , 0xa9},
  {0xf1 , 0x00},
  {0xfd , 0x01},
  {0x90 , 0x0c},
  {0x92 , 0x01},
  {0x98 , 0xa9},
  {0x99 , 0x00},
  {0x9a , 0x01},
  {0x9b , 0x00},
  //Status
  {0xfd , 0x01},
  {0xce , 0xec},
  {0xcf , 0x07},
  {0xd0 , 0xec},
  {0xd1 , 0x07},
  {0xd7 , 0xab},
  {0xd8 , 0x00},
  {0xd9 , 0xaf},
  {0xda , 0x00},
  {0xfd , 0x00},


  {0xfd , 0x00},
  {0x03 , 0x07},
  {0x04 , 0x9e},
  {0x05 , 0x00},
  {0x06 , 0x00},
  {0x07 , 0x00},
  {0x08 , 0x00},
  {0x09 , 0x00},
  {0x0a , 0xd4},
  {0x2f , 0x00},
	{0x30 , 0x0c},
  {0xf0 , 0x45},
  {0xf1 , 0x01},
  {0xfd , 0x01},
  {0x90 , 0x04},
  {0x92 , 0x01},
  {0x98 , 0x45},
  {0x99 , 0x01},
  {0x9a , 0x01},
  {0x9b , 0x00},
  //Status
  {0xfd , 0x01},
  {0xce , 0x14},
  {0xcf , 0x05},
  {0xd0 , 0x14},
  {0xd1 , 0x05},
  {0xd7 , 0x41},
  {0xd8 , 0x01},
  {0xd9 , 0x45},
  {0xda , 0x01},
  {0xfd , 0x00},
#else
    /* 24M Fixed 10frame */
  {0xfd , 0x00},
  {0x03 , 0x03},
  {0x04 , 0x0C},
  {0x05 , 0x00},
  {0x06 , 0x00},
  {0x07 , 0x00},
  {0x08 , 0x00},
  {0x09 , 0x00},
  {0x0a , 0xE4},
  {0x2f , 0x00},
  {0x30 , 0x11},
  {0xf0 , 0x82},
  {0xf1 , 0x00},
  {0xfd , 0x01},
  {0x90 , 0x0A},
  {0x92 , 0x01},
  {0x98 , 0x82},
  {0x99 , 0x01},
  {0x9a , 0x01},
  {0x9b , 0x00},
  //Status
  {0xfd , 0x01},
  {0xce , 0x14},
  {0xcf , 0x05},
  {0xd0 , 0x14},
  {0xd1 , 0x05},
  {0xd7 , 0x7E},
  {0xd8 , 0x00},
  {0xd9 , 0x82},
  {0xda , 0x00},
  {0xfd , 0x00},
#endif /* CONFIG_VIDEO_SP2518_FIXED_FRAMERATE */

  {0xfd,0x01},
  {0xca,0x30},//mean dummy2low
  {0xcb,0x50},//mean low2dummy
  {0xcc,0xc0},//f8,rpc low
  {0xcd,0xc0},//rpc dummy
  {0xd5,0x80},//mean normal2dummy
	{0xd6,0x90},//mean dummy2normal
  {0xfd,0x00},
  //lens shading for ˴̩979C-171A\181A
  {0xfd,0x00},
  {0xa1,0x20},
  {0xa2,0x20},
  {0xa3,0x20},
  {0xa4,0xff},
  {0xa5,0x80},
  {0xa6,0x80},
  {0xfd,0x01},
  {0x64,0x1e},//28
  {0x65,0x1c},//25
  {0x66,0x1c},//2a
  {0x67,0x16},//25
  {0x68,0x1c},//25
  {0x69,0x1c},//29
  {0x6a,0x1a},//28
  {0x6b,0x16},//20
  {0x6c,0x1a},//22
  {0x6d,0x1a},//22
  {0x6e,0x1a},//22
  {0x6f,0x16},//1c
  {0xb8,0x04},//0a
  {0xb9,0x13},//0a
  {0xba,0x00},//23
  {0xbb,0x03},//14
  {0xbc,0x03},//08
  {0xbd,0x11},//08
  {0xbe,0x00},//12
  {0xbf,0x02},//00
  {0xc0,0x04},//05
  {0xc1,0x0e},//05
  {0xc2,0x00},//18
  {0xc3,0x05},//08
  //raw filter
  {0xfd,0x01},
  {0xde,0x0f},
  {0xfd,0x00},
  {0x57,0x08},//raw_dif_thr
  {0x58,0x08},//a
  {0x56,0x08},//a
  {0x59,0x10},
  //R\Bͨ?<?ƽ??
  {0x5a,0xa0},//raw_rb_fac_outdoor
  {0xc4,0xa0},//60raw_rb_fac_indoor
  {0x43,0xa0},//40raw_rb_fac_dummy
  {0xad,0x40},//raw_rb_fac_low
  //Gr??Gb ͨ???ڲ?ƽ??
  {0x4f,0xa0},//raw_gf_fac_outdoor
  {0xc3,0xa0},//60raw_gf_fac_indoor
  {0x3f,0xa0},//40raw_gf_fac_dummy
  {0x42,0x40},//raw_gf_fac_low
  {0xc2,0x15},
  //Gr??Gbͨ?<?ƽ??
  {0xb6,0x80},//raw_gflt_fac_outdoor
  {0xb7,0x80},//60raw_gflt_fac_normal
  {0xb8,0x40},//40raw_gflt_fac_dummy
  {0xb9,0x20},//raw_gflt_fac_low
  //Gr??Gbͨ????ֵ
  {0xfd,0x01},
  {0x50,0x0c},//raw_grgb_thr
	{0x51,0x0c},
  {0x52,0x10},
  {0x53,0x10},
  {0xfd,0x00},
  // awb1
  {0xfd,0x01},
  {0x11,0x10},
  {0x12,0x1f},
  {0x16,0x1c},
  {0x18,0x00},
  {0x19,0x00},
  {0x1b,0x96},
  {0x1a,0x9a},//95
  {0x1e,0x2f},
  {0x1f,0x29},
  {0x20,0xff},
  {0x22,0xff},
  {0x28,0xce},
  {0x29,0x8a},
  {0xfd,0x00},
  {0xe7,0x03},
  {0xe7,0x00},
  {0xfd,0x01},
  {0x2a,0xf0},
  {0x2b,0x10},
  {0x2e,0x04},
  {0x2f,0x18},
  {0x21,0x60},
  {0x23,0x60},
  {0x8b,0xab},
  {0x8f,0x12},
  //awb2
  {0xfd,0x01},
  {0x1a,0x80},
  {0x1b,0x80},
  {0x43,0x80},
   //outdoor
    {0x00,0xd4},
    {0x01,0xb0},
    {0x02,0x90},
    {0x03,0x78},
  //d65
  {0x35,0xd6},//d6,b0
  {0x36,0xf0},//f0,d1,e9
  {0x37,0x7a},//8a,70
  {0x38,0x9a},//dc,9a,af
  //indoor
  {0x39,0xab},
  {0x3a,0xca},
  {0x3b,0xa3},
  {0x3c,0xc1},
  //f
  {0x31,0x82},//7d
  {0x32,0xa5},//a0,74
  {0x33,0xd6},//d2
  {0x34,0xec},//e8
  {0x3d,0xa5},//a7,88
  {0x3e,0xc2},//be,bb
  {0x3f,0xa7},//b3,ad
  {0x40,0xc5},//c5,d0
  //Color Correction
  {0xfd,0x01},
	{0x1c,0xc0},
  {0x1d,0x95},
  {0xa0,0xa6},//b8
  {0xa1,0xda},//,d5
  {0xa2,0x00},//,f2
  {0xa3,0x06},//,e8
  {0xa4,0xb2},//,95
  {0xa5,0xc7},//,03
  {0xa6,0x00},//,f2
  {0xa7,0xce},//,c4
  {0xa8,0xb2},//,ca
  {0xa9,0x0c},//,3c
  {0xaa,0x30},//,03
  {0xab,0x0c},//,0f
  {0xac,0xc0},//b8
  {0xad,0xc0},//d5
  {0xae,0x00},//f2
  {0xaf,0xf2},//e8
  {0xb0,0xa6},//95
  {0xb1,0xe8},//03
  {0xb2,0x00},//f2
  {0xb3,0xe7},//c4
  {0xb4,0x99},//ca
  {0xb5,0x0c},//3c
  {0xb6,0x33},//03
  {0xb7,0x0c},//0f
  //Saturation
  {0xfd,0x00},
  {0xbf,0x01},
  {0xbe,0xbb},
  {0xc0,0xb0},
  {0xc1,0xf0},
  {0xd3,0x77},
  {0xd4,0x77},
  {0xd6,0x77},
  {0xd7,0x77},
  {0xd8,0x77},
  {0xd9,0x77},
  {0xda,0x77},
  {0xdb,0x77},
  //uv_dif
  {0xfd,0x00},
  {0xf3,0x03},
  {0xb0,0x00},
  {0xb1,0x23},
  //gamma1
  {0xfd,0x00},//
  {0x8b,0x0 },//0 ,0
  {0x8c,0xA },//14,A
  {0x8d,0x13},//24,13
  {0x8e,0x25},//3a,25
  {0x8f,0x43},//59,43
  {0x90,0x5D},//6f,5D
  {0x91,0x74},//84,74
  {0x92,0x88},//95,88
  {0x93,0x9A},//a3,9A
  {0x94,0xA9},//b1,A9
  {0x95,0xB5},//be,B5
  {0x96,0xC0},//c7,C0
  {0x97,0xCA},//d1,CA
  {0x98,0xD4},//d9,D4
  {0x99,0xDD},//e1,DD
	{0x9a,0xE6},//e9,E6
  {0x9b,0xEF},//f1,EF
  {0xfd,0x01},//01,01
  {0x8d,0xF7},//f9,F7
  {0x8e,0xFF},//ff,FF
  //gamma2
  {0xfd,0x00},//
  {0x78,0x0 },//0
  {0x79,0xA },//14
  {0x7a,0x13},//24
  {0x7b,0x25},//3a
  {0x7c,0x43},//59
  {0x7d,0x5D},//6f
  {0x7e,0x74},//84
  {0x7f,0x88},//95
  {0x80,0x9A},//a3
  {0x81,0xA9},//b1
  {0x82,0xB5},//be
  {0x83,0xC0},//c7
  {0x84,0xCA},//d1
  {0x85,0xD4},//d9
  {0x86,0xDD},//e1
  {0x87,0xE6},//e9
  {0x88,0xEF},//f1
  {0x89,0xF7},//f9
  {0x8a,0xFF},//ff
      /*//???߹??Ⱥ?
 //gamma1
  {0xfd,0x00},
  {0x8b,0x00},
  {0x8c,0x14},
  {0x8d,0x24},
  {0x8e,0x3A},
  {0x8f,0x59},
  {0x90,0x70},
  {0x91,0x85},
  {0x92,0x96},
  {0x93,0xA6},
  {0x94,0xB3},
  {0x95,0xBE},
  {0x96,0xC9},
  {0x97,0xD2},
  {0x98,0xDB},
  {0x99,0xE3},
  {0x9a,0xEB},
  {0x9b,0xF2},
  {0xfd,0x01},
  {0x8d,0xF9},
  {0x8e,0xFF},
//gamma2
  {0xfd,0x00},
  {0x78,0x00},
  {0x79,0x14},
  {0x7a,0x24},
  {0x7b,0x3A},
  {0x7c,0x59},
  {0x7d,0x70},
  {0x7e,0x85},
  {0x7f,0x96},
  {0x80,0xA6},
  {0x81,0xB3},
  {0x82,0xBE},
	 {0x83,0xC9},
  {0x84,0xD2},
  {0x85,0xDB},
  {0x86,0xE3},
  {0x87,0xEB},
  {0x88,0xF2},
  {0x89,0xF9},
  {0x8a,0xFF},
*/
  //gamma_ae
  {0xfd,0x01},
  {0x96,0x46},
  {0x97,0x14},
  {0x9f,0x06},
  //HEQ
  {0xfd,0x00},//
  {0xdd,0x80},//
  {0xde,0x95},//a0
  {0xdf,0x80},//
  //Ytarget
  {0xfd,0x00},//
  {0xec,0x70},//6a
  {0xed,0x86},//7c
  {0xee,0x70},//65
  {0xef,0x86},//78
  {0xf7,0x80},//78
  {0xf8,0x74},//6e
  {0xf9,0x80},//74
  {0xfa,0x74},//6a
  //sharpen
  {0xfd,0x01},
  {0xdf,0x0f},
  {0xe5,0x10},
  {0xe7,0x10},
  {0xe8,0x20},
  {0xec,0x20},
  {0xe9,0x20},
  {0xed,0x20},
  {0xea,0x10},
  {0xef,0x10},
  {0xeb,0x10},
  {0xf0,0x10},
  //,gw
  {0xfd,0x01},//
  {0x70,0x76},//
  {0x7b,0x40},//
  {0x81,0x30},//
  //,Y_offset
  {0xfd,0x00},
  {0xb2,0x10},
  {0xb3,0x1f},
  {0xb4,0x30},
  {0xb5,0x50},
  //,CNR
  {0xfd,0x00},
  {0x5b,0x20},
  {0x61,0x80},
  {0x77,0x80},
  {0xca,0x80},
  //,YNR
  {0xab,0x00},
	{0xac,0x02},
  {0xae,0x08},
  {0xaf,0x20},
  {0xfd,0x00},
  {0x31,0x10},
  {0x32,0x0d},
  {0x33,0xcf},//ef
  {0x34,0x7f},//3f
  {0xe7,0x03},
  {0xe7,0x00},

    // psw0523 test
#if 1
    {0xfd, 0x00},
    {0x36, 0x1f}, // bit1: ccir656 output enable
    {0x4b, 0x00},
    {0x4c, 0x00},
    {0x47, 0x00},
    {0x48, 0x00},
    {0xfd, 0x01},
    {0x06, 0x00},
    {0x07, 0x40},
    {0x08, 0x00},
    {0x09, 0x40},
    {0x0a, 0x02},
    {0x0b, 0x58},
    {0x0c, 0x03},
    {0x0d, 0x20},
    {0x0e, 0x21},
    {0xfd, 0x00},
#endif
#if 0
//[KEUN]win reg 800x600
	  {0xfd, 0x00},
    {0x36, 0x1f}, // bit1: ccir656 output enable
    {0x47, 0x00},
    {0x48, 0x00},
    {0x49, 0x04},
    {0x4a, 0xb0},
    {0x4b, 0x00},
    {0x4c, 0x00},
    {0x4d, 0x06},
    {0x4e, 0x40},
    {0xfd, 0x01},
    {0x06, 0x00},
    {0x07, 0x40},
    {0x08, 0x00},
    {0x09, 0x40},
    {0x0a, 0x02},
    {0x0b, 0x58},
    {0x0c, 0x03},
    {0x0d, 0x20},
    {0x0e, 0x21},
    {0xfd, 0x00},

//[KEUN]set bus foramt - sp2518_fmt_yuv422_yuyv
		//YCbYCr
    {0xfd,0x00},
    {0x35,0x40},		
#endif
    END_MARKER, 
};

#else

//HEQ
#define  SP2518_P0_0xdd  0x7c	//0x80 modify by sp_yjp,20120814
#define  SP2518_P0_0xde  0x90	//0x95 modify by sp_yjp,20120814

/* init 640X480 VGA */
static struct reg_val _sensor_init_data[] =
{
	#if 1
	{0xfd,0x00},
	{0x1b,0x1a},//maximum drv ability //0x02 modify by sp_yjp,20120809
	{0x0e,0x01},

	{0x0f,0x2f},
	{0x10,0x2e},
	{0x11,0x00},
	{0x12,0x4f},
	{0x14,0x20},
	{0x16,0x02},
	{0x17,0x10},
	{0x1a,0x1f},
	{0x1e,0x81},
	{0x21,0x00},
	{0x22,0x1b},
	{0x25,0x10},
	{0x26,0x25},
	{0x27,0x6d},
	{0x2c,0x31},//Ronlus remove balck dot0x45},
	{0x2d,0x75},
	{0x2e,0x38},//sxga 0x18

	{0x31,0x10},//mirror upside down
	{0x44,0x03},
	{0x6f,0x00},
	{0xa0,0x04},
	{0x5f,0x01},
	{0x32,0x00},
	{0xfd,0x01},
	{0x2c,0x00},
	{0x2d,0x00},
	{0xfd,0x00},
	{0xfb,0x83},
	{0xf4,0x09},
	//Pregain
	{0xfd,0x01},
	{0xc6,0x90},
	{0xc7,0x90},
	{0xc8,0x90},
	{0xc9,0x90},
	//blacklevel
	{0xfd,0x00},
	{0x65,0x08},
	{0x66,0x08},
	{0x67,0x08},
	{0x68,0x08},

	//bpc
	{0x46,0xff},
	//rpc
	{0xfd,0x00},
	{0xe0,0x6c},
	{0xe1,0x54},
	{0xe2,0x48},
	{0xe3,0x40},
	{0xe4,0x40},
	{0xe5,0x3e},
	{0xe6,0x3e},
	{0xe8,0x3a},
	{0xe9,0x3a},
	{0xea,0x3a},
	{0xeb,0x38},
	{0xf5,0x38},
	{0xf6,0x38},
	{0xfd,0x01},
	{0x94,0xc0},//f8
	{0x95,0x38},
	{0x9c,0x6c},
	{0x9d,0x38},	


	#if 0
	///SP2518 UXGA 24MEclk 3倍频 1分频 50Hz fix 11fps
	{0xfd , 0x00},
	{0x03 , 0x03},
	{0x04 , 0xa8},
	{0x05 , 0x00},
	{0x06 , 0x6d},
	{0x07 , 0x00},
	{0x08 , 0x6d},
	{0x09 , 0x00},
	{0x0a , 0xe4},
	{0x2f , 0x00},
	{0x30 , 0x08},
	{0xf0 , 0x9c},
	{0xf1 , 0x00},
	{0xfd , 0x01},
	{0x90 , 0x09},
	{0x92 , 0x01},
	{0x98 , 0x9c},
	{0x99 , 0x00},
	{0x9a , 0x01},
	{0x9b , 0x00},
	///Status
	{0xfd , 0x01},
	{0xce , 0x7c},
	{0xcf , 0x05},
	{0xd0 , 0x7c},
	{0xd1 , 0x05},
	{0xd7 , 0x98},
	{0xd8 , 0x00},
	{0xd9 , 0x9c},
	{0xda , 0x00},
	{0xfd , 0x00},
	#endif

	#if 1
	///SP2518 UXGA 24MEclk 3倍频 1分频 50Hz fix 10fps
	{0xfd , 0x00},
	{0x03 , 0x03},
	{0x04 , 0x66},
	{0x05 , 0x00},
	{0x06 , 0x8b},
	{0x07 , 0x00},
	{0x08 , 0x8b},
	{0x09 , 0x01},
	{0x0a , 0x3b},
	{0x2f , 0x00},
	{0x30 , 0x08},
	{0xf0 , 0x91},
	{0xf1 , 0x00},
	{0xfd , 0x01},
	{0x90 , 0x0a},
	{0x92 , 0x01},
	{0x98 , 0x91},
	{0x99 , 0x00},
	{0x9a , 0x01},
	{0x9b , 0x00},
	///Status 
	{0xfd , 0x01},
	{0xce , 0xaa},
	{0xcf , 0x05},
	{0xd0 , 0xaa},
	{0xd1 , 0x05},
	{0xd7 , 0x8d},
	{0xd8 , 0x00},
	{0xd9 , 0x91},
	{0xda , 0x00},
	{0xfd , 0x00},
	#endif
	
	
	#if 0
	/// UXGA 24MEclk 3倍频 1分频 50Hz fix 9fps
	{0xfd , 0x00},
	{0x03 , 0x03},
	{0x04 , 0x42},
	{0x05 , 0x00},
	{0x06 , 0xf0},
	{0x07 , 0x00},
	{0x08 , 0xf0},
	{0x09 , 0x01},
	{0x0a , 0x71},
	{0x2f , 0x00},
	{0x30 , 0x08},
	{0xf0 , 0x8b},
	{0xf1 , 0x00},
	{0xfd , 0x01},
	{0x90 , 0x0b},
	{0x92 , 0x01},
	{0x98 , 0x8b},
	{0x99 , 0x00},
	{0x9a , 0x01},
	{0x9b , 0x00},
	///Status  
	{0xfd , 0x01},
	{0xce , 0xf9},
	{0xcf , 0x05},
	{0xd0 , 0xf9},
	{0xd1 , 0x05},
	{0xd7 , 0x87},
	{0xd8 , 0x00},
	{0xd9 , 0x8b},
	{0xda , 0x00},
	{0xfd , 0x00},
	#endif
	
	#if 0
	/*24*3pll 8~13fps 50hz*/
	{0xfd , 0x00},
	{0x03 , 0x03},
	{0x04 , 0xf6},
	{0x05 , 0x00},
	{0x06 , 0x00},
	{0x07 , 0x00},
	{0x08 , 0x00},
	{0x09 , 0x00},
	{0x0a , 0x8b},
	///////////////////SP2518_write_cmos_sensor(0x2f , 0x00},	modify by sp_yjp,20120809
	{0x30 , 0x08},	//0x08 modify by sp_yjp,20120809
	{0xf0 , 0xa9},
	{0xf1 , 0x00},
	{0xfd , 0x01},
	{0x90 , 0x0c},
	{0x92 , 0x01},
	{0x98 , 0xa9},
	{0x99 , 0x00},
	{0x9a , 0x01},
	{0x9b , 0x00},
	
	//Status
	{0xfd , 0x01},
	{0xce , 0xec},
	{0xcf , 0x07},
	{0xd0 , 0xec},
	{0xd1 , 0x07},
	{0xd7 , 0xa5},
	{0xd8 , 0x00},
	{0xd9 , 0xa9},
	{0xda , 0x00},
	{0xfd , 0x00},
	#endif

	{0xfd,0x01},
	{0xca,0x30},//mean dummy2low
	{0xcb,0x50},//mean low2dummy
	{0xcc,0xc0},//f8;rpc low
	{0xcd,0xc0},//rpc dummy
	{0xd5,0x80},//mean normal2dummy
	{0xd6,0x90},//mean dummy2normal
	{0xfd,0x00},  
	
	//lens shading 
	{0xfd,0x00},
	{0xa1,0x20},
	{0xa2,0x20},
	{0xa3,0x20},
	{0xa4,0xff},
	{0xa5,0x80},
	{0xa6,0x80},
	{0xfd,0x01},
	{0x64,0x1e},//28
	{0x65,0x1c},//25
	{0x66,0x1c},//2a
	{0x67,0x16},//25
	{0x68,0x1c},//25
	{0x69,0x1c},//29
	{0x6a,0x1a},//28
	{0x6b,0x16},//20
	{0x6c,0x1a},//22
	{0x6d,0x1a},//22
	{0x6e,0x1a},//22
	{0x6f,0x16},//1c
	{0xb8,0x04},//0a
	{0xb9,0x13},//0a
	{0xba,0x00},//23
	{0xbb,0x03},//14
	{0xbc,0x03},//08
	{0xbd,0x11},//08
	{0xbe,0x00},//12
	{0xbf,0x02},//00
	{0xc0,0x04},//05
	{0xc1,0x0e},//05
	{0xc2,0x00},//18
	{0xc3,0x05},//08   
	//raw filter
	{0xfd,0x01},
	{0xde,0x0f},
	{0xfd,0x00},
	{0x57,0x08},//raw_dif_thr
	{0x58,0x08},//a
	{0x56,0x08},//a
	{0x59,0x10},

	{0x5a,0xa0},//raw_rb_fac_outdoor
	{0xc4,0xa0},//60raw_rb_fac_indoor
	{0x43,0xa0},//40raw_rb_fac_dummy  
	{0xad,0x40},//raw_rb_fac_low  

	{0x4f,0xa0},//raw_gf_fac_outdoor
	{0xc3,0xa0},//60raw_gf_fac_indoor
	{0x3f,0xa0},//40raw_gf_fac_dummy
	{0x42,0x40},//raw_gf_fac_low
	{0xc2,0x15},

	{0xb6,0x80},//raw_gflt_fac_outdoor
	{0xb7,0x80},//60raw_gflt_fac_normal
	{0xb8,0x40},//40raw_gflt_fac_dummy
	{0xb9,0x20},//raw_gflt_fac_low

	{0xfd,0x01},
	{0x50,0x0c},//raw_grgb_thr
	{0x51,0x0c},
	{0x52,0x10},
	{0x53,0x10},
	{0xfd,0x00},	
	// awb1
	{0xfd,0x01},
	{0x11,0x10},
	{0x12,0x1f},
	{0x16,0x1c},
	{0x18,0x00},
	{0x19,0x00},
	{0x1b,0x96},
	{0x1a,0x9a},//95
	{0x1e,0x2f},
	{0x1f,0x29},
	{0x20,0xff},
	{0x22,0xff},  
	{0x28,0xce},
	{0x29,0x8a},
	{0xfd,0x00},
	{0xe7,0x03},
	{0xe7,0x00},
	{0xfd,0x01},
	{0x2a,0xf0},
	{0x2b,0x10},
	{0x2e,0x04},
	{0x2f,0x18},
	{0x21,0x60},
	{0x23,0x60},
	{0x8b,0xab},
	{0x8f,0x12},
	//awb2
	{0xfd,0x01},
	{0x1a,0x80},
	{0x1b,0x80},
	{0x43,0x80},
	//d65
	{0x35,0xd6},//d6;b0
	{0x36,0xf0},//f0;d1;e9
	{0x37,0x7a},//8a;70
	{0x38,0x9a},//dc;9a;af
	//indoor
	{0x39,0xab},
	{0x3a,0xca},
	{0x3b,0xa3},
	{0x3c,0xc1},
	//f
	{0x31,0x82},//7d
	{0x32,0xa5},//a0;74
	{0x33,0xd6},//d2
	{0x34,0xec},//e8
	{0x3d,0xa5},//a7;88
	{0x3e,0xc2},//be;bb
	{0x3f,0xa7},//b3;ad
	{0x40,0xc5},//c5;d0
	//Color Correction				  
	{0xfd,0x01},
	{0x1c,0xc0},
	{0x1d,0x95},
	{0xa0,0xa6},//b8 
	{0xa1,0xda},//;d5
	{0xa2,0x00},//;f2
	{0xa3,0x06},//;e8
	{0xa4,0xb2},//;95
	{0xa5,0xc7},//;03
	{0xa6,0x00},//;f2
	{0xa7,0xce},//;c4
	{0xa8,0xb2},//;ca
	{0xa9,0x0c},//;3c
	{0xaa,0x30},//;03
	{0xab,0x0c},//;0f
	{0xac,0xc0},//b8 
	{0xad,0xc0},//d5
	{0xae,0x00},//f2
	{0xaf,0xf2},//e8
	{0xb0,0xa6},//95
	{0xb1,0xe8},//03
	{0xb2,0x00},//f2
	{0xb3,0xe7},//c4
	{0xb4,0x99},//ca
	{0xb5,0x0c},//3c
	{0xb6,0x33},//03
	{0xb7,0x0c},//0f
	//Saturation
	{0xfd,0x00},
	{0xbf,0x01},
	{0xbe,0xbb},
	{0xc0,0xb0},
	{0xc1,0xf0},
	
	{0xd3,0x68},	//0x77 modify by sp_yjp,20120814
	{0xd4,0x68},	//0x77 modify by sp_yjp,20120814
	{0xd6,0x68},	//0x77 modify by sp_yjp,20120814
	{0xd7,0x68},	//0x77 modify by sp_yjp,20120814
	{0xd8,0x68},	//0x77 modify by sp_yjp,20120814
	{0xd9,0x68},	//0x77 modify by sp_yjp,20120814
	{0xda,0x68},	//0x77 modify by sp_yjp,20120814
	{0xdb,0x68},	//0x77 modify by sp_yjp,20120814
	//uv_dif
	{0xfd,0x00},
	{0xf3,0x03},
	{0xb0,0x00},
	{0xb1,0x23},
	//gamma1
	{0xfd,0x00},//
	{0x8b,0x0 },//0 ;0	
	{0x8c,0xA },//14;A 
	{0x8d,0x13},//24;13
	{0x8e,0x25},//3a;25
	{0x8f,0x43},//59;43
	{0x90,0x5D},//6f;5D
	{0x91,0x74},//84;74
	{0x92,0x88},//95;88
	{0x93,0x9A},//a3;9A
	{0x94,0xA9},//b1;A9
	{0x95,0xB5},//be;B5
	{0x96,0xC0},//c7;C0
	{0x97,0xCA},//d1;CA
	{0x98,0xD4},//d9;D4
	{0x99,0xDD},//e1;DD
	{0x9a,0xE6},//e9;E6
	{0x9b,0xEF},//f1;EF
	{0xfd,0x01},//01;01
	{0x8d,0xF7},//f9;F7
	{0x8e,0xFF},//ff;FF
	//gamma2   
	{0xfd,0x00},//
	{0x78,0x0 },//0   
	{0x79,0xA },//14
	{0x7a,0x13},//24
	{0x7b,0x25},//3a
	{0x7c,0x43},//59
	{0x7d,0x5D},//6f
	{0x7e,0x74},//84
	{0x7f,0x88},//95
	{0x80,0x9A},//a3
	{0x81,0xA9},//b1
	{0x82,0xB5},//be
	{0x83,0xC0},//c7
	{0x84,0xCA},//d1
	{0x85,0xD4},//d9
	{0x86,0xDD},//e1
	{0x87,0xE6},//e9
	{0x88,0xEF},//f1
	{0x89,0xF7},//f9
	{0x8a,0xFF},//ff
	//gamma_ae  
	{0xfd,0x01},
	{0x96,0x46},
	{0x97,0x14},
	{0x9f,0x06},
	//HEQ
	{0xfd,0x00},//
	{0xdd,SP2518_P0_0xdd},//0x80	   
	{0xde,SP2518_P0_0xde},//a0	
	{0xdf,0x80},//
	//Ytarget 
	{0xfd,0x00},// 
	{0xec,0x70},//6a
	{0xed,0x86},//7c
	{0xee,0x70},//65
	{0xef,0x86},//78
	{0xf7,0x80},//78
	{0xf8,0x74},//6e
	{0xf9,0x80},//74
	{0xfa,0x74},//6a 
	//sharpen
	{0xfd,0x01},
	{0xdf,0x0f},
	{0xe5,0x10},
	{0xe7,0x10},
	{0xe8,0x20},
	{0xec,0x20},
	{0xe9,0x20},
	{0xed,0x20},
	{0xea,0x10},
	{0xef,0x10},
	{0xeb,0x10},
	{0xf0,0x10},
	//;gw
	{0xfd,0x01},//
	{0x70,0x76},//
	{0x7b,0x40},//
	{0x81,0x30},//
	//;Y_offset
	{0xfd,0x00},
	{0xb2,0X10},
	{0xb3,0x1f},
	{0xb4,0x30},
	{0xb5,0x50},
	//;CNR
	{0xfd,0x00},
	{0x5b,0x20},
	{0x61,0x80},
	{0x77,0x80},
	{0xca,0x80},
	//;YNR  
	{0xab,0x00},
	{0xac,0x02},
	{0xae,0x08},
	{0xaf,0x20},
	{0xfd,0x00},
	{0x31,0x10},
	{0x32,0x0d},
	{0x33,0xcf},//ef
	{0x34,0x7f},//3f
	
	{0x35,0x40},//3        
	
	{0x1b,0x02},
	{0xe7,0x03},
	{0xe7,0x00},

	//SP2518_config_window(WINDOW_SIZE_VGA}
	#if 0
	{0xfd,0x00},
	{0x4b,0x00},
	{0x4c,0x00},
	{0x47,0x00},
	{0x48,0x00},
	{0x4d,0x06},
	{0x4e,0x40},
	{0x49,0x04},
	{0x4a,0xb0},

	{0xfd,0x01},
	{0x06,0x00},
	{0x07,0x50},
	{0x08,0x00},
	{0x09,0x50},
	{0x0a,0x01},	//480
	{0x0b,0xe0},	
	{0x0c,0x02},	//640
	{0x0d,0x80},
	{0x0e,0x01},
	{0xfd,0x00},	
	#else	
	{0xfd,0x00},
	{0x4b,0x00},
	{0x4c,0x00},
	{0x47,0x00},
	{0x48,0x00},
	{0x4d,0x06},
	{0x4e,0x40},
	{0x49,0x04},
	{0x4a,0xb0},
	
	{0xfd,0x01},
	{0x06,0x00},
	{0x07,0x40},
	{0x08,0x00},
	{0x09,0x40},
	{0x0a,0x02},	//600
	{0x0b,0x58},
	{0x0c,0x03},	//800
	{0x0d,0x20},
	
	{0x0e,0x01},
	#endif
	#endif

	{0x5d,0x0e},	
	{0xff,0xff},//The end flag
};
#endif


static struct reg_val _sensor_dis_data[] =
{
    {0xfd, 0x00},
    {0x36, 0x00},
    {0xfd, 0x00},
    END_MARKER,
};


#ifdef FEATURE_TW9992
static struct reg_val tw9992_sensor_init_data[] =
{
	0x00, 0x92,
	0x01, 0x00,
	0x02, 0x40,
	0x03, 0x78,
	0x04, 0x00,
	0x05, 0x09,
	0x06, 0x00,
	0x07, 0x02,
	0x08, 0x12,
	0x09, 0xF0,
	0x0A, 0x09,
	0x0B, 0xD1,
	0x0C, 0xCC,
	0x0D, 0x00,
	0x10, 0x00,
	0x11, 0x64,
	0x12, 0x11,
	0x13, 0x80,
	0x14, 0x80,
	0x15, 0x00,
	0x17, 0x80,
	0x18, 0x44,
	0x19, 0x06,
	0x1A, 0x10,
	0x1B, 0x00,
	0x1C, 0x0F,		//0x08,
	0x1D, 0x7F,
	0x1F, 0x00,
	0x20, 0x50,
	0x21, 0x22,
	0x22, 0xF0,
	0x23, 0xD8,
	0x24, 0xBC,
	0x25, 0xB8,
	0x26, 0x44,
	0x27, 0x38,
	0x28, 0x00,
	0x29, 0x00,
	0x2A, 0x78,
	0x2B, 0x44,
	0x2C, 0x30,
	0x2D, 0x14,
	0x2E, 0xA5,
	0x2F, 0xE0,
	0x30, 0x00,
	0x31, 0x10,
	0x32, 0xFF,
	0x33, 0x05,
	0x34, 0x1A,
	0x35, 0x00,
	0x36, 0x7A,			//0x5A, requested by Daniel Kim, 09242014
	0x37, 0x18,
	0x38, 0xDD,
	0x39, 0x00,
	0x3A, 0x30,
	0x3B, 0x00,
	0x3C, 0x00,
	0x3D, 0x00,
	0x3F, 0x1A,
	0x40, 0x80,
	0x41, 0x00,
	0x42, 0x00,
	0x48, 0x02,
	0x49, 0x00,
	0x4A, 0x81,
	0x4B, 0x0A,
	0x4C, 0x00,
	0x4D, 0x01,
	0x4E, 0x01,
	0x50, 0x00,
	0x51, 0x00,
	0x52, 0x00,
	0x53, 0x00,
	0x54, 0x06,
	0x55, 0x00,
	0x56, 0x00,
	0x57, 0x00,
	0x58, 0x00,
	0x60, 0x00,
	0x61, 0x00,
	0x62, 0x00,
	0x63, 0x00,
	0xC0, 0x06,
	0xC1, 0x20,

	0x71, 0xA5,
	0xA2, 0x30,
	0x70, 0x01, //start with MIPI Normal operation

	0x07, 0x02, //using Shadow Register so no Input cropping setting for NTSC
	0x08, 0x15,
	0x09, 0xf0,
	0x0a, 0x14,
	0x0b, 0xd0,

	END_MARKER,
};
#endif

#define CAMERA_POWER_EN			(PAD_GPIO_C + 4) 
#define CAMERA_RESET       	(PAD_GPIO_C + 5) 
#define CAMERA_POWER_PD			(PAD_GPIO_C + 6)


#if 0
static unsigned long    clk_in_max = 0;
#define DUTY_MIN_VAL  2

unsigned long pwm_set_frequency(int ch, unsigned int request, unsigned int duty)
{
  //struct pwm_device *pwm = &devs_pwm[ch];
  struct pwm_device *pwm = &pwm_dev[ch];
  volatile unsigned long rate, freq, clock = 0;
  volatile unsigned long hz = 0, pwmhz = 0;
  volatile unsigned int tcnt;
  int i, n, end = 0;


	printf("[%s] ch : %d\n", ch);
	printf("[%s] duty : %d\n", duty);
  printf("[%s] request : %d\n", request);
#if 0
  //RET_ASSERT_VAL(PWN_CHANNELS > ch, -EINVAL);
  //RET_ASSERT_VAL(ch >= 0, -EINVAL);
  //RET_ASSERT_VAL(100 >= duty && duty >= 0, -EINVAL);

	if( PWN_CHANNELS > ch )
	{
		printf("PWN_CHANNELS > ch	error...!!\n");
		return -EINVAL;
	}
#endif

	clk_in_max  = clk_get_rate(clk);
	clk_in_max /= 2;

  if (request > (clk_in_max/DUTY_MIN_VAL)) {
    printf("Invalid request=%u hz over max pwm out %ld hz\n",
      request, (clk_in_max/DUTY_MIN_VAL));
    return -EINVAL;
  }
  if (0 == duty) {
    pwm->compare = 0;
    pwm->request = request;
    //pwm_set_device(pwm);
    return request;
  }

  /* for suspend -> resume */
    if (pwm->request == request) {
        clock = pwm->rate;
        pwmhz = pwm->pwm_hz;
    }

  /* change only dutycycle */
  if (pwm->request == request && pwm->duty != duty) {
    clock = pwm->rate;
    pwmhz = pwm->pwm_hz;
  /* set new pwm out */
  } else {
    for (n = 1; !end; n *= 10) {
      for (i = (n == 1 ? DUTY_MIN_VAL : 1); 10 > i; i++) {
        freq = request * i * n;
        if (freq > clk_in_max) {
          end = 1;
          break;
        }
        rate = clk_round_rate(pwm->clk, feeq);

        tcnt = rate/request;
        hz = rate/tcnt;
        if (0 == rate%request) {
          clock = rate, pwmhz = hz, end = 1;
          break;
        }

        if (hz && (abs(hz-request) >= abs(pwmhz-request)))
          continue;
        clock = rate, pwmhz = hz;
      }
    }
	}

	if (clock) {
    pwm->request = request;
    pwm->rate = clock;
    pwm->duty = duty;
    pwm->pwm_hz = pwmhz;
    pwm->counter = clock/request;
    pwm->compare = PWM_COMPARE(pwm->counter, duty) ? : 1;
   // pwm_set_device(pwm);
  } else {
        printk("%s: can't find clock!!!\n", __func__);
    }


  return clock ? pwm->pwm_hz : 0;
}
#endif

static int _sensor_set_clock(ulong clk_rate)
{
	unsigned long result=0;
	static int _init = 0;
	static bool enable_pwm = false;

	printf("+++ [%s] +++\n", __func__);
  if (!_init) {

		printf("[%s] clk_rate : %ld\n", __func__, clk_rate);
    pwm_init(1, 0, 0); 
    _init = 1;
  }

#if 0
    if (clk_rate > 0)
       result = pwm_set_frequency(1, clk_rate, 50);
    else
        result = pwm_set_frequency(1, 0, 0);

		printf("[%s] result : %ld\n", __func__, result);
#else

#if 0
  pwm_config(1,
    TO_DUTY_NS( 50, clk_rate),
    TO_PERIOD_NS(clk_rate));
#else
	pwm_config_camera(1, clk_rate, 50);

#endif
	if( !enable_pwm )
		pwm_enable(1);

	enable_pwm = true;

#endif

		printf("--- [%s] ---\n", __func__);
    mdelay(1);
    return 0;
}

#if 1
static void camera_power_control(int enable)
{
	u8 val;
	static bool power_control = false;

	struct axp228_power power = {
    .i2c_addr = AXP228_I2C_ADDR,
    .i2c_bus = CONFIG_PMIC_I2C_BUS,
  };

	printf("+++ [%s] +++\n", __func__);
	printf("[%s] enable : %d\n", __func__, enable);
	if( power_control )
		return;

	power_control = true;

	axp228_i2c_set_bits(&power, AXP22_LDO_DC_EN2, 1<<AXP_DLDO2_EN_BIT);
	/* REG 16H:DLDO2 Output Voltage Set */
  val = axp228_get_vol_step(AXP_DLDO2_VALUE, AXP22_DLDO2_STEP, AXP22_DLDO2_MIN, AXP22_DLDO2_MAX);
  axp228_i2c_write(&power, AXP22_DLDO2OUT_VOL, val);

	printf("--- [%s] ---\n", __func__);
}
#endif

static int _sensor_power_enable(bool enable)
{
    u32 io	 			= CAMERA_POWER_EN;
    u32 reset_io 	= CAMERA_RESET;
    u32 io_pd 		= CAMERA_POWER_PD;

		printf("[%s] enable : %d\n", __func__, enable);
		
		printf("+++ [%s] +++\n", __func__);
    if (enable) {
				/* PD signal */
				//gpio_direction_output(io_pd, 1);
				//gpio_set_alt(io_pd, 1);
				gpio_set_value(io_pd, 1);

				camera_power_control(1);

				/* PN signal */
				gpio_set_value(io, 0);
				gpio_direction_output(io, 1);
				gpio_set_alt(io, 1);
				gpio_set_value(io, 1);
				_sensor_set_clock(24000000);
				mdelay(1);
				gpio_set_value(io, 0);

				/* RST signal */
				gpio_set_value(reset_io, 1);
				gpio_direction_output(reset_io, 1);
				gpio_set_alt(reset_io, 1);
				gpio_set_value(reset_io, 0);
				mdelay(10);
				gpio_set_value(reset_io, 1);
				mdelay(10);
				mdelay(1000);
    }
		printf("--- [%s] ---\n", __func__);
		
    return 0;
}

static void _sensor_setup_io(void)
{
		static bool io_enable = false;
    u_int *pad;
    int i, len;
    u_int io, fn;

		if( io_enable )
			return;

		io_enable = true;

		printf("+++ [%s] +++\n", __func__);
    /* VIP0:0 = VCLK, VID0 ~ 7 */
    const u_int port[][2] = {
        /* VCLK, HSYNC, VSYNC */
        { PAD_GPIO_A + 28, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_E + 13, NX_GPIO_PADFUNC_2 },
        { PAD_GPIO_E +  7, NX_GPIO_PADFUNC_2 },
        /* DATA */
        { PAD_GPIO_A + 30, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B +  0, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_B +  2, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B +  4, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_B +  6, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B +  8, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_B +  9, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B + 10, NX_GPIO_PADFUNC_1 },
    };

    pad = (u_int *)port;
    len = sizeof(port)/sizeof(port[0]);

    for (i = 0; i < len; i++) {
        io = *pad++;
        fn = *pad++;
        gpio_direction_input(io);
        gpio_set_alt(io, fn);
    }
		printf("--- [%s] ---\n", __func__);
}

static struct camera_sensor_data _sensor_data = {
		 .module				=	VIP_MODULE_NUM, 
     .bus       		= 0,
     /*.chip      	= 0x88 >> 1,*/
     .chip      		= 0x60>>1,
     .reg_val   		= _sensor_init_data,
     .reg_val_dis		= _sensor_dis_data,
     .power_enable 	= _sensor_power_enable,
		 .clock_invert	=	true,
		 .clk_rate			=	24000000,
     .set_clock 		= _sensor_set_clock,
     .setup_io  		= _sensor_setup_io,
};

#define CAM_WIDTH       800
#define CAM_HEIGHT      600

static struct nxp_vip_param _vip_param = {
    // interlace
    .port           = 0,
    .external_sync  = false,
    .is_mipi        = false,
    .h_active       = CAM_WIDTH,
    .h_frontporch   = 7,
    .h_syncwidth    = 1,
    .h_backporch    = 10,
    .v_active       = CAM_HEIGHT,
    .v_frontporch   = 0,
    .v_syncwidth    = 2,
    .v_backporch    = 3,
    .data_order     = 2,
    .interlace      = false,
};

static struct nxp_mlc_video_param _mlc_param = {
    .format         = NX_MLC_YUVFMT_420,
    .width          = CAM_WIDTH,
    .height         = CAM_HEIGHT,
    .left           = 0,
    .top            = 0,
#if 1 // apply screen width, height
    .right          = 0,
    .bottom         = 0,
#else
    .right          = CAM_WIDTH,
    .bottom         = CAM_HEIGHT,
#endif
    .priority       = 0,
};


#ifdef FEATURE_TW9992
static int tw9992_sensor_power_enable(bool enable)
{
    unsigned int reset_io = ((PAD_GPIO_ALV + 0));

    if (enable) {
        // reset to high
        gpio_direction_output(reset_io, 1);
        gpio_set_alt(reset_io, 0);
        mdelay(1);

        // reset to low
        gpio_set_value(reset_io, 0);
        mdelay(10);

        // reset to high
        gpio_set_value(reset_io, 1);
        mdelay(10);
    }

    return 0;
}


static struct camera_sensor_data tw9992_sensor_data = {
     .bus       = 4,
     .chip      = 0x7a >> 1,
     .reg_val   = tw9992_sensor_init_data,
     .power_enable = tw9992_sensor_power_enable,
     .set_clock = NULL,
     .setup_io  = NULL,
};

static struct nxp_vip_param tw9992_vip_param = {
    // interlace
    .port           = 1,
    .external_sync  = true,
    .is_mipi        = true,
    .h_active       = CAM_WIDTH,
    .h_frontporch   = 7,
    .h_syncwidth    = 1,
    .h_backporch    = 10,
    .v_active       = CAM_HEIGHT,
    .v_frontporch   = 0,
    .v_syncwidth    = 2,
    .v_backporch    = 3,
    .data_order     = 0,
    .interlace      = true,
};
#endif



int module_id = VIP_MODULE_NUM;

void camera_run(void)
{
#ifndef FEATURE_TW9992
    int camera_id = camera_register_sensor(&_sensor_data);
    camera_sensor_run(camera_id);
    nxp_vip_register_param(module_id, &_vip_param);

#else
	int ret = 0;

    int camera_id = camera_register_sensor(&tw9992_sensor_data);
    camera_sensor_run(camera_id);

	{
		u8 read_val = 0;
		ret= i2c_read(tw9992_sensor_data.chip, 0x00, 1, &read_val, 1);
		printf("tw9992 read id:0x%x, ret:%d \n", read_val, ret);
	}

	module_id = 1;
    nxp_vip_register_param(module_id, &tw9992_vip_param);
#endif

    nxp_vip_set_addr(module_id, CONFIG_VIP_LU_ADDR, CONFIG_VIP_CB_ADDR, CONFIG_VIP_CR_ADDR);

    nxp_mlc_video_set_param(0, &_mlc_param);
    nxp_mlc_video_set_addr(0, CONFIG_VIP_LU_ADDR, CONFIG_VIP_CB_ADDR, CONFIG_VIP_CR_ADDR,
            ALIGN(CAM_WIDTH, 64),
            ALIGN(CAM_WIDTH/2, 64),
            ALIGN(CAM_WIDTH/2, 64));
    /*printf("%s exit\n", __func__);*/
}

//#define CAMERA_ACTIVE_DETECT (PAD_GPIO_A + 3)
//#define CAMERA_DETECT_ACTIVE_VALUE 0
void camera_preview(void)
{
  //  int io = CAMERA_ACTIVE_DETECT;
  //  int val;

    //gpio_direction_input(io);
    //gpio_set_alt(io, 0);
    //val = gpio_get_value(io);

    //if (val == CAMERA_DETECT_ACTIVE_VALUE) {
        printf("run vip & mlc\n");
        nxp_vip_run(module_id);
        nxp_mlc_video_run(0);
    //}
    /*printf("%s exit\n", __func__);*/
}
